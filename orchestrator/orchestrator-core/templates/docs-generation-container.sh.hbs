#!/bin/sh

echo '════════════════════════════════════════════════════════════════'
echo '║                 DOCS GENERATION STARTING                     ║'
echo '════════════════════════════════════════════════════════════════'

# Setup authentication based on repository URL type
{{#if repository}}
REPO_URL="{{repository.url}}"
if echo "$REPO_URL" | grep -q "^git@\|^ssh://"; then
  echo "SSH repository URL detected"
  USE_SSH=true
else
  echo "HTTPS repository URL detected"
  USE_SSH=false
fi

# SSH Authentication Setup
if [ "$USE_SSH" = "true" ]; then
  echo "=== SSH AUTHENTICATION SETUP ==="

  # Check if SSH key is mounted (mounted to /ssh-keys by orchestrator)
  if [ -f "/ssh-keys/ssh-privatekey" ]; then
    echo "✓ SSH private key found"

    # Create .ssh directory with proper permissions
    mkdir -p /root/.ssh
    chmod 700 /root/.ssh

    # Copy SSH keys to writable location with correct permissions
    cp /ssh-keys/ssh-privatekey /root/.ssh/id_rsa
    chmod 600 /root/.ssh/id_rsa

    # Copy public key if available
    if [ -f "/ssh-keys/ssh-publickey" ]; then
      cp /ssh-keys/ssh-publickey /root/.ssh/id_rsa.pub
      chmod 644 /root/.ssh/id_rsa.pub
    fi

    # Add GitHub to known hosts
    ssh-keyscan github.com >> /root/.ssh/known_hosts 2>/dev/null || echo "Warning: Failed to add GitHub to known hosts"

    # Test SSH connection
    echo "Testing SSH connection to GitHub..."
    ssh -T git@github.com 2>&1 | head -3 || echo "SSH test completed (expected to fail with 'successfully authenticated')"

    # Configure git user
    git config --global user.name "{{repository.githubUser}}"
    git config --global user.email "{{repository.githubUser}}@users.noreply.github.com"

    echo "✓ SSH authentication configured successfully"
  else
    echo "❌ SSH private key not found at /ssh-keys/ssh-privatekey"
    echo "   Expected SSH key secret to be mounted at /ssh-keys"
    exit 1
  fi
else
  # HTTPS Authentication Setup (existing logic)
  echo "=== HTTPS AUTHENTICATION SETUP ==="

# Source GitHub environment if it exists
if [ -f /workspace/.github-env ]; then
  . /workspace/.github-env
  echo "✓ GitHub authentication configured"

  # Configure git credentials for HTTPS authentication
  if [ -n "$GITHUB_TOKEN" ] && [ -n "$GITHUB_USER" ]; then
    git config --global user.name "$GITHUB_USER"
    git config --global user.email "${GITHUB_USER}@users.noreply.github.com"

    # Ensure git credentials file exists with correct format
    echo "https://${GITHUB_USER}:${GITHUB_TOKEN}@github.com" > /workspace/.git-credentials
    chmod 600 /workspace/.git-credentials

    # Configure git to use the credentials
    git config --global credential.helper 'store --file=/workspace/.git-credentials'
    cd /workspace && git config credential.helper 'store --file=/workspace/.git-credentials'

    echo "✓ Git credentials configured for user: $GITHUB_USER"
  fi
fi
fi
{{else}}
echo "⚠️ No repository configured for authentication setup"
{{/if}}

# Clone repository to get .taskmaster directory and project files
echo "=== REPOSITORY SETUP ==="

{{#if repository}}
# Repository information
REPO_URL="{{repository.url}}"
REPO_BRANCH="{{repository.branch}}"
GITHUB_USER="{{repository.githubUser}}"

echo "Cloning repository: $REPO_URL"
echo "Branch: $REPO_BRANCH"
echo "GitHub User: $GITHUB_USER"

# Clone the repository to /workspace
if [ -d "/workspace/.git" ]; then
  echo "Repository already exists, pulling latest changes..."
  cd /workspace
  git fetch origin
  git checkout "$REPO_BRANCH"
  git pull origin "$REPO_BRANCH"
else
  echo "Cloning repository..."
  echo "DEBUG: Contents of /workspace before clone:"
  ls -la /workspace

  # Handle non-empty workspace directory by temporarily backing up existing files
  if [ "$(ls -A /workspace 2>/dev/null)" ]; then
    echo "Workspace is not empty, backing up existing files..."
    BACKUP_DIR="/tmp/workspace-backup"
    rm -rf "$BACKUP_DIR"
    mkdir -p "$BACKUP_DIR"

    # Backup existing files (like .gitconfig)
    cp -r /workspace/. "$BACKUP_DIR/" 2>/dev/null || true

    # Clear workspace for clean clone
    rm -rf /workspace/*
    rm -rf /workspace/.[^.]*  # Remove hidden files but keep . and ..

    if ! git clone --depth 1 --branch "$REPO_BRANCH" "$REPO_URL" /workspace; then
      echo ""
      echo "═══════════════════════════════════════════════════════════════"
      echo "║                   REPOSITORY CLONE FAILED                    ║"
      echo "═══════════════════════════════════════════════════════════════"
      echo ""
      echo "❌ Failed to clone repository: $REPO_URL"
      echo "   Branch: $REPO_BRANCH"
      echo ""
      echo "Possible causes:"
      echo "  • Invalid repository URL"
      echo "  • Branch '$REPO_BRANCH' does not exist"
      echo "  • GitHub authentication failed"
      echo "  • Network connectivity issues"
      echo ""
      echo "🚫 DOCS GENERATION CANNOT PROCEED WITHOUT REPOSITORY"
      echo ""
      exit 1
    fi

    # Restore backed up files that don't conflict with repository
    echo "Restoring non-conflicting workspace files..."
    for file in "$BACKUP_DIR"/.gitconfig "$BACKUP_DIR"/.github-env "$BACKUP_DIR"/.git-credentials; do
      if [ -f "$file" ]; then
        cp "$file" /workspace/ 2>/dev/null || true
        echo "✓ Restored: $(basename "$file")"
      fi
    done
    cd /workspace
  else
    # Workspace is empty, clone directly
    if ! git clone --depth 1 --branch "$REPO_BRANCH" "$REPO_URL" /workspace; then
      echo ""
      echo "═══════════════════════════════════════════════════════════════"
      echo "║                   REPOSITORY CLONE FAILED                    ║"
      echo "═══════════════════════════════════════════════════════════════"
      echo ""
      echo "❌ Failed to clone repository: $REPO_URL"
      echo "   Branch: $REPO_BRANCH"
      echo ""
      echo "Possible causes:"
      echo "  • Invalid repository URL"
      echo "  • Branch '$REPO_BRANCH' does not exist"
      echo "  • GitHub authentication failed"
      echo "  • Network connectivity issues"
      echo ""
      echo "🚫 DOCS GENERATION CANNOT PROCEED WITHOUT REPOSITORY"
      echo ""
      exit 1
    fi
    cd /workspace
  fi
fi

echo "✓ Repository cloned successfully"
{{else}}
echo ""
echo "═══════════════════════════════════════════════════════════════"
echo "║                NO REPOSITORY CONFIGURED                      ║"
echo "═══════════════════════════════════════════════════════════════"
echo ""
echo "❌ CRITICAL ERROR: No repository configured for docs generation"
echo ""
echo "Docs generation requires:"
echo "  • Repository URL to clone source code"
echo "  • .taskmaster directory with tasks.json"
echo "  • Git repository for committing generated docs"
echo ""
echo "🚫 DOCS GENERATION CANNOT PROCEED WITHOUT REPOSITORY"
echo ""
exit 1
{{/if}}

# Copy ConfigMap files to working directory (AFTER repository clone)
echo "=== CONFIGMAP FILE SETUP ==="

# Determine the working directory for Claude
WORKING_DIR="{{working_dir}}"
if [ -n "$WORKING_DIR" ] && [ "$WORKING_DIR" != "." ]; then
  CLAUDE_WORK_DIR="/workspace/$WORKING_DIR"
else
  CLAUDE_WORK_DIR="/workspace"
fi

echo "Setting up files in Claude working directory: $CLAUDE_WORK_DIR"
# Note: Directory should already exist from repository clone, but ensure it exists
mkdir -p "$CLAUDE_WORK_DIR"

# Copy all files from ConfigMap to working directory
if [ -d "/config" ]; then
  echo "Copying ConfigMap files to working directory..."

  # Copy markdown files (force overwrite any existing files)
  cp -f /config/*.md "$CLAUDE_WORK_DIR/" 2>/dev/null && echo "✓ Copied markdown files (overwriting existing)" || echo "! No markdown files to copy"

  # Create enterprise managed settings for HIGHEST precedence (guaranteed override)
  echo "=== ENTERPRISE MANAGED SETTINGS (Highest Precedence) ==="
  mkdir -p /etc/claude-code
  chmod 755 /etc/claude-code

  # Copy Claude settings as enterprise managed settings for highest precedence
  if [ -f "/config/claude-settings.json" ]; then
    cp /config/claude-settings.json /etc/claude-code/managed-settings.json
    # Set explicit permissions so Claude Code can read the enterprise settings
    chmod 644 /etc/claude-code/managed-settings.json
    echo "✓ Copied claude-settings.json as enterprise managed settings to /etc/claude-code/managed-settings.json"
    echo "✓ Set readable permissions (644) for enterprise settings"
  else
    echo "❌ ERROR: Claude settings template not found in ConfigMap!"
    echo "Expected: /config/claude-settings.json"
    exit 1
  fi

  # Validate the enterprise settings JSON
  if jq empty /etc/claude-code/managed-settings.json 2>/dev/null; then
    echo "✓ Enterprise settings JSON is valid"
    echo "✓ This will override ALL other Claude Code settings (highest precedence)"
    echo "✓ Model configuration, tools, and hooks are all defined"

    echo ""
    echo "Enterprise settings contents:"
    cat /etc/claude-code/managed-settings.json | jq . 2>/dev/null || cat /etc/claude-code/managed-settings.json
  else
    echo "❌ Enterprise settings JSON is invalid"
    cat /etc/claude-code/managed-settings.json
    exit 1
  fi

  echo ""
  echo "=== UNIFIED CONFIGURATION: Enterprise Managed Settings ==="
  echo "✓ All Claude Code configuration in one comprehensive settings file"
  echo "✓ Model: claude-opus-4-20250514"
  echo "✓ Hooks: Early test hooks + final PR creation hook"
  echo "✓ Permissions: acceptEdits mode + --dangerously-skip-permissions flag"
  echo "✓ No additional settings files needed"

  # Copy hook scripts
  cp /config/.stop-hook-docs-pr.sh "$CLAUDE_WORK_DIR/.stop-hook-docs-pr.sh" 2>/dev/null && echo "✓ Copied stop hook script" || echo "! No stop hook script to copy"
  chmod +x "$CLAUDE_WORK_DIR/.stop-hook-docs-pr.sh" 2>/dev/null

  cp /config/.early-hook-test.sh "$CLAUDE_WORK_DIR/.early-hook-test.sh" 2>/dev/null && echo "✓ Copied early hook test script" || echo "! No early hook test script to copy"
  chmod +x "$CLAUDE_WORK_DIR/.early-hook-test.sh" 2>/dev/null

  echo "✓ ConfigMap files copied to $CLAUDE_WORK_DIR"
else
  echo "⚠️  Warning: /config directory not found (ConfigMap not mounted?)"
fi

echo '=== WORKSPACE VALIDATION ==='

# Check for required files in Claude's working directory
MISSING_FILES=""
REQUIRED_FILES="CLAUDE.md .stop-hook-docs-pr.sh"

echo "Checking for required files..."
for file in $REQUIRED_FILES; do
  if [ ! -f "$CLAUDE_WORK_DIR/$file" ]; then
    echo "ERROR: Missing required file: $CLAUDE_WORK_DIR/$file"
    MISSING_FILES="$MISSING_FILES $file"
  else
    echo "✓ Found: $CLAUDE_WORK_DIR/$file"
    # Show file size for verification
    size=$(wc -c < "$CLAUDE_WORK_DIR/$file" 2>/dev/null || echo "0")
    echo "  File size: $size bytes"
  fi
done

# If any files are missing, abort
if [ -n "$MISSING_FILES" ]; then
  echo ""
  echo "═══════════════════════════════════════════════════════════════"
  echo "║                 WORKSPACE VALIDATION FAILED                  ║"
  echo "═══════════════════════════════════════════════════════════════"
  echo ""
  echo "The following required files are missing:"
  for missing in $MISSING_FILES; do
    case "$missing" in
      "CLAUDE.md")
        echo "  ❌ $missing - Main prompt file with task instructions"
        ;;
      ".stop-hook-docs-pr.sh")
        echo "  ❌ $missing - Post-completion hook for auto-commit and PR creation"
        ;;
      *)
        echo "  ❌ $missing"
        ;;
    esac
  done
  echo ""
  echo "These files should have been created by the ConfigMap setup process."
  echo "Claude will NOT be started to avoid wasting API credits."
  echo ""
  exit 1
fi

echo "✓ All required files present. Workspace is valid."

echo '=== DOCUMENTATION GENERATION DIAGNOSTICS ==='
echo "Project directory: $CLAUDE_WORK_DIR"
echo "Project directory contents:"
ls -la "$CLAUDE_WORK_DIR"
echo ""

# Check for REQUIRED .taskmaster directory and tasks.json
CRITICAL_MISSING=""

if [ ! -d "$CLAUDE_WORK_DIR/.taskmaster" ]; then
  echo "✗ CRITICAL ERROR: .taskmaster directory not found!"
  CRITICAL_MISSING="$CRITICAL_MISSING .taskmaster"
else
  echo "✓ Found .taskmaster directory"
  if [ ! -f "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json" ]; then
    echo "✗ CRITICAL ERROR: tasks/tasks.json not found!"
    CRITICAL_MISSING="$CRITICAL_MISSING tasks.json"
  else
    echo "✓ Found tasks/tasks.json"
    task_count=$(jq '.tasks | length' "$CLAUDE_WORK_DIR/.taskmaster/tasks/tasks.json" 2>/dev/null || echo "unknown")
    echo "  Task count: $task_count"
  fi
fi

# Check git repository (REQUIRED for docs generation)
# Note: Git repository is always at /workspace root, not the Claude working directory
if [ ! -d "/workspace/.git" ]; then
  echo "✗ CRITICAL ERROR: No git repository found!"
  CRITICAL_MISSING="$CRITICAL_MISSING git-repository"
else
  echo "✓ Found: git repository"
fi

# ABORT if any critical components are missing
if [ -n "$CRITICAL_MISSING" ]; then
  echo ""
  echo "═══════════════════════════════════════════════════════════════"
  echo "║                CRITICAL VALIDATION FAILED                    ║"
  echo "═══════════════════════════════════════════════════════════════"
  echo ""
  echo "❌ CRITICAL COMPONENTS MISSING:"
  for missing in $CRITICAL_MISSING; do
    case "$missing" in
      ".taskmaster")
        echo "  • .taskmaster directory - Required for task definitions"
        ;;
      "tasks.json")
        echo "  • tasks.json file - Required for documentation generation"
        ;;
      "git-repository")
        echo "  • Git repository - Required for committing and pushing docs"
        ;;
      *)
        echo "  • $missing"
        ;;
    esac
  done
  echo ""
  echo "🚫 DOCS GENERATION CANNOT PROCEED WITHOUT THESE COMPONENTS"
  echo ""
  echo "This indicates a fundamental setup issue:"
  echo "  - Repository may not have been cloned properly"
  echo "  - .taskmaster directory missing from repository"
  echo "  - Git authentication may have failed"
  echo ""
  echo "Claude will NOT be started to avoid wasting API credits."
  echo ""
  exit 1
fi

echo '=== CLAUDE EXECUTION ==='

# Export necessary variables for the stop hook
export SERVICE_NAME="{{service_name}}"
export TARGET_BRANCH="{{targetBranch}}"
export SOURCE_BRANCH="{{repository.branch}}"
export WORKING_DIR="{{working_dir}}"
export GITHUB_USER="{{repository.githubUser}}"

# Enterprise managed settings provide comprehensive configuration:
# - Model selection, tools, hooks, environment variables
# - Combined with --dangerously-skip-permissions flag for guaranteed permission bypass
echo "✓ Using enterprise managed settings for complete configuration + permission bypass flag"

# Change to project directory before running Claude
cd "$CLAUDE_WORK_DIR"
echo "Changed to directory: $(pwd)"

# Verify we're in the correct directory and have required files
echo "=== WORKING DIRECTORY VERIFICATION ==="
echo "Current working directory: $(pwd)"
echo "Expected directory: $CLAUDE_WORK_DIR"
if [ "$(pwd)" != "$CLAUDE_WORK_DIR" ]; then
  echo "❌ ERROR: Failed to change to correct working directory!"
  echo "Attempting to change directory again..."
  cd "$CLAUDE_WORK_DIR" || exit 1
  echo "✓ Successfully changed to: $(pwd)"
fi

# Print all the content Claude will receive
echo ""
echo "════════════════════════════════════════════════════════════════"
echo "║                    FULL CONTENT PREVIEW                       ║"
echo "════════════════════════════════════════════════════════════════"
echo ""

echo "=== 1. ENTERPRISE MANAGED SETTINGS (/etc/claude-code/managed-settings.json) ==="
if [ -f "/etc/claude-code/managed-settings.json" ]; then
  echo "Enterprise settings contents:"
  cat "/etc/claude-code/managed-settings.json" | jq . 2>/dev/null || cat "/etc/claude-code/managed-settings.json"
else
  echo "❌ Enterprise settings file not found!"
fi
echo ""

echo "=== 2. HOOK SCRIPT (.stop-hook-docs-pr.sh) ==="
if [ -f ".stop-hook-docs-pr.sh" ]; then
  echo "Hook script contents:"
  cat ".stop-hook-docs-pr.sh"
else
  echo "❌ Hook script not found!"
fi
echo ""

echo "=== 3. CLAUDE PROMPT (CLAUDE.md) ==="
if [ -f "CLAUDE.md" ]; then
  echo "Full CLAUDE.md contents:"
  cat "CLAUDE.md"
else
  echo "❌ CLAUDE.md not found!"
fi
echo ""

echo "=== 4. ADDITIONAL MARKDOWN FILES ==="
echo "Other markdown files in working directory:"
for md_file in *.md; do
  if [ -f "$md_file" ] && [ "$md_file" != "CLAUDE.md" ]; then
    echo ""
    echo "--- FILE: $md_file ---"
    cat "$md_file"
    echo ""
  fi
done
echo ""

echo "=== 5. TASKMASTER TASKS.JSON ==="
if [ -f ".taskmaster/tasks/tasks.json" ]; then
  echo "Tasks.json contents:"
  cat ".taskmaster/tasks/tasks.json" | jq . 2>/dev/null || cat ".taskmaster/tasks/tasks.json"
else
  echo "❌ tasks.json not found!"
fi
echo ""

echo "════════════════════════════════════════════════════════════════"
echo "║                    END CONTENT PREVIEW                        ║"
echo "════════════════════════════════════════════════════════════════"
echo ""

# Build Claude command with --dangerously-skip-permissions to bypass all permission prompts
# This is simpler and more reliable than enterprise managed settings for permission control
CLAUDE_CMD="claude -p --output-format stream-json --verbose"

echo "=== 6. ENVIRONMENT VARIABLES ==="
echo "Environment variables Claude will see:"
env | grep -E '^(CLAUDE|ANTHROPIC|OTEL|SERVICE_NAME|TARGET_BRANCH|SOURCE_BRANCH|WORKING_DIR|GITHUB|NODE_ENV|DISABLE)' | sort || echo "No relevant env vars found"
echo ""

echo "=== 7. WORKING DIRECTORY STATE ==="
echo "Current working directory: $(pwd)"
echo "Directory contents:"
ls -la
echo ""
echo "Git status:"
git status 2>/dev/null || echo "Not a git repository or git not available"
echo ""

echo "════════════════════════════════════════════════════════════════"
echo "║                    STARTING CLAUDE EXECUTION                  ║"
echo "════════════════════════════════════════════════════════════════"
echo "Command: $CLAUDE_CMD"
echo "Note: Claude will automatically read CLAUDE.md from the working directory"
echo "Starting Claude execution..."
echo "=========================="

# Run Claude with proper separation of memory vs prompt
# CLAUDE.md = Project memory (automatically loaded by Claude)
# Prompt = Task-specific instruction from template

# Load the prompt template content
PROMPT="{{prompt_content}}"

echo "=== 8. FINAL EXECUTION ==="
echo "CLAUDE.md (project memory): Will be automatically loaded by Claude"
echo "Prompt (task instruction): $PROMPT"
echo "=== END EXECUTION INFO ==="
echo ""

# Create a wrapper script that runs Claude and then our PR logic
cat > "/tmp/claude-with-pr.sh" << 'EOF'
#!/bin/bash
set -e

echo "🤖 Starting Claude documentation generation..."
CLAUDE_CMD="claude -p --output-format stream-json --verbose"
PROMPT="$1"

# Run Claude
$CLAUDE_CMD "$PROMPT"
CLAUDE_EXIT_CODE=$?

echo ""
echo "=== POST-CLAUDE PROCESSING ==="
echo "🤖 Claude finished with exit code: $CLAUDE_EXIT_CODE"

if [ $CLAUDE_EXIT_CODE -eq 0 ]; then
    echo "✅ Claude completed successfully - proceeding with PR creation"

    # Source GitHub environment if available
    if [ -f ".github-env" ]; then
        source .github-env
        echo "✅ Loaded GitHub environment"
    else
        echo "⚠️  Warning: .github-env not found"
    fi

    # Check if we have any documentation changes
    if ! git diff --quiet HEAD -- .taskmaster/docs/ 2>/dev/null || ! git diff --cached --quiet HEAD -- .taskmaster/docs/ 2>/dev/null; then
        echo "📝 Documentation changes detected"
    else
        echo "ℹ️  No documentation changes to commit"
        echo "Checking if there are any untracked documentation files..."

        # Check for untracked files in the docs directory
        UNTRACKED_DOCS=$(git ls-files --others --exclude-standard .taskmaster/docs/ 2>/dev/null | wc -l)
        if [ "$UNTRACKED_DOCS" -eq 0 ]; then
            echo "No untracked documentation files found - exiting"
            exit 0
        else
            echo "Found $UNTRACKED_DOCS untracked documentation files"
        fi
    fi

    # Add all documentation changes
    echo "Adding documentation changes..."
    git add .taskmaster/docs/ || {
        echo "❌ Failed to add documentation changes"
        exit 1
    }

    # Create commit message
    COMMIT_MSG="docs: Auto-generated documentation via orchestrator

- Generated comprehensive task documentation
- Updated task breakdown and implementation details
- Added acceptance criteria and prompts

Generated by: orchestrator docs generation"

    # Commit changes
    echo "Committing changes..."
    if git commit -m "$COMMIT_MSG"; then
        echo "✅ Successfully committed documentation changes"
    else
        echo "❌ Failed to commit changes"
        exit 1
    fi

    # Get current branch
    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    echo "Current branch: $CURRENT_BRANCH"

    # Push changes to current branch
    echo "Pushing changes to $CURRENT_BRANCH..."
    if git push origin "$CURRENT_BRANCH"; then
        echo "✅ Successfully pushed changes to $CURRENT_BRANCH"
    else
        echo "❌ Failed to push changes"
        exit 1
    fi

    # Check if we should create a PR (only if not on main/master)
    if [ "$CURRENT_BRANCH" != "main" ] && [ "$CURRENT_BRANCH" != "master" ]; then
        echo "🔄 Creating pull request for documentation updates..."

        # Create PR using GitHub CLI if available
        if command -v gh >/dev/null 2>&1; then
            # Check if PR already exists
            EXISTING_PR=$(gh pr list --head "$CURRENT_BRANCH" --json number --jq '.[0].number' 2>/dev/null || echo "")

            if [ -n "$EXISTING_PR" ] && [ "$EXISTING_PR" != "null" ]; then
                echo "📋 Pull request #$EXISTING_PR already exists for branch $CURRENT_BRANCH"
                echo "🔗 Updated existing PR with latest documentation changes"
            else
                # Create new PR
                PR_TITLE="docs: Auto-generated documentation updates"
                PR_BODY="## 📚 Documentation Updates

This PR contains auto-generated documentation updates from the orchestrator docs generation system.

### Changes Made:
- ✅ Generated comprehensive task documentation
- ✅ Updated task breakdown and implementation details
- ✅ Added acceptance criteria and prompts

### Generated Files:
- Task documentation (task.md)
- Implementation prompts (prompt.md)
- Acceptance criteria (acceptance-criteria.md)

---
🤖 **Auto-generated by:** orchestrator docs generation"

                if gh pr create --title "$PR_TITLE" --body "$PR_BODY" --base main; then
                    echo "✅ Successfully created pull request"
                    # Get the PR number
                    PR_NUMBER=$(gh pr list --head "$CURRENT_BRANCH" --json number --jq '.[0].number')
                    echo "🔗 Pull request created: #$PR_NUMBER"
                else
                    echo "⚠️  Failed to create pull request, but changes were pushed successfully"
                fi
            fi
        else
            echo "⚠️  GitHub CLI not available - changes pushed but no PR created"
            echo "📝 Manual PR creation required for branch: $CURRENT_BRANCH"
        fi
    else
        echo "ℹ️  On main branch - no pull request needed"
    fi

    echo "🎉 Documentation generation and PR creation completed successfully!"
else
    echo "❌ Claude failed with exit code: $CLAUDE_EXIT_CODE"
    echo "Skipping PR creation due to Claude failure"
    exit $CLAUDE_EXIT_CODE
fi
EOF

chmod +x /tmp/claude-with-pr.sh

# Now exec our wrapper script instead of Claude directly
exec /tmp/claude-with-pr.sh "$PROMPT"